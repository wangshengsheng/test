1. 中心服务器模式使用dubbo rpc，现在Qps在2000以下，需要优化。
2. 当前实现的接口增加一个API, 批量产生ID，也就是需要一次产生多个ID的接口。
3. 实现一版有持久的发号器，可以在Redis或者数据库中持久一个数据，在各个节点上读取并且增加，可以使用CAS提高效率，还可以一段一段的取ID，例如，某个节点一次取从10-20的ID，然后，一个一个吐给客户端，到了20后，再取50-60等等，但是，如果有多个节点的时候，也不是严格递增的，但是整体是递增的。
4. 第4条中如果只有一个节点提供服务，那将是严格递增的，但是，还是可能出现某段ID会丢失，这种情况在节点宕机的时候出现丢弃缓存的那段ID而产生的。
5. 嵌入模式需要配置机器ID，不同节点机器ID不一样，这个打包会有麻烦，最好支持Zookeeper分配机器ID。
6. 让vesta发号器的ID的每个部分都是可配置的，提供预制的一些provider, 比如，机器号provider，sequence provider, 时间provider, 类型provider等等。
7. 为了满足团购码的生成，我们需要让其随机，而不是连续的，那么，需要对生成的数据进行bit_shuffle, 参考：http://cloudate.net/?p=1732
8. 好朋友张宁同学提醒，VestaServer在线上cpu占用高，等待设计问题，需要使用sleep或者join或者wait来实现
9. 可以注册到Spring Cloud的Eruka上的功能
10. source code copy and use version简化版本
11. 参考发号器的并发实现：http://blog.csdn.net/lianhuazy167/article/details/66967665
12. 当前实现在当前的时间单位内，ID用完后，就会等待，考虑当前时间单位的ID用完后，是否可以提前使用后续事件的ID，等请求量下去了，生成的ID又回到了当前时间